{"ast":null,"code":"var _jsxFileName = \"/Users/lawrencehan/Documents/GitHub/hanlarry/src/components/background/BackgroundCanvas.tsx\";\nimport React, { useRef, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { DoubleSide, FrontSide } from 'three';\nimport { Canvas, useFrame } from '@react-three/fiber';\nimport './background.css';\nimport { noise } from '../../Perlin';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function BackgroundCanvas(props) {\n  var _s = $RefreshSig$(),\n      _s2 = $RefreshSig$(),\n      _s3 = $RefreshSig$(),\n      _s4 = $RefreshSig$(),\n      _s5 = $RefreshSig$(),\n      _s6 = $RefreshSig$();\n\n  const {\n    darkMode\n  } = props;\n  const [darkColor, lightColor] = [0x2A2B2A, 0xFCF7FF]; // When forming a MESH with useFrame(), it must be its own component, outside of App()\n\n  function Sphere(props) {\n    _s();\n\n    const mesh = useRef(null);\n    useFrame((state, delta) => mesh.current.rotation.x += 0.01);\n    useFrame((state, delta) => mesh.current.rotation.y += 0.01);\n    return /*#__PURE__*/_jsxDEV(\"mesh\", { ...props,\n      ref: mesh,\n      children: [/*#__PURE__*/_jsxDEV(\"sphereGeometry\", {\n        args: [1, 128, 128]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 24,\n        columnNumber: 13\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"meshNormalMaterial\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 25,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 21,\n      columnNumber: 11\n    }, this);\n  }\n\n  _s(Sphere, \"FIkUQYXLgs6Y9py+5HT08fVwj9E=\", false, function () {\n    return [useFrame, useFrame];\n  });\n\n  function Skeleton(props) {\n    _s2();\n\n    const mesh = useRef(null);\n    useFrame((state, delta) => mesh.current.rotation.x -= 0.005);\n    useFrame((state, delta) => mesh.current.rotation.y -= 0.005);\n    return /*#__PURE__*/_jsxDEV(\"mesh\", { ...props,\n      ref: mesh,\n      children: [/*#__PURE__*/_jsxDEV(\"icosahedronGeometry\", {\n        args: [1.5, 2]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 37,\n        columnNumber: 17\n      }, this), \"  \", /*#__PURE__*/_jsxDEV(\"meshPhongMaterial\", {\n        color: \"#ffffff\",\n        wireframe: true,\n        wireframeLinewidth: 200,\n        side: DoubleSide\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 38,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 34,\n      columnNumber: 13\n    }, this);\n  }\n\n  _s2(Skeleton, \"FIkUQYXLgs6Y9py+5HT08fVwj9E=\", false, function () {\n    return [useFrame, useFrame];\n  });\n\n  function BackgroundPlane(props) {\n    _s3();\n\n    const meshPlane = useRef(null);\n    return /*#__PURE__*/_jsxDEV(\"mesh\", { ...props,\n      receiveShadow: true,\n      ref: meshPlane,\n      children: [/*#__PURE__*/_jsxDEV(\"planeGeometry\", {\n        attach: \"geometry\",\n        args: [1000, 1000]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 49,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"meshStandardMaterial\", {\n        attach: \"material\",\n        color: darkMode ? darkColor : lightColor,\n        side: DoubleSide,\n        transparent: true,\n        opacity: 0.3\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 50,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 45,\n      columnNumber: 13\n    }, this);\n  }\n\n  _s3(BackgroundPlane, \"i0FhoLYRwqolUHtM1b5wa6m35WI=\");\n\n  function BlurPlane(props) {\n    _s4();\n\n    const meshPlane = useRef(null);\n    useEffect(() => {// meshPlane.current.rotation.x = Math.PI / 4 * -1\n    });\n    return /*#__PURE__*/_jsxDEV(\"mesh\", { ...props,\n      ref: meshPlane,\n      children: [/*#__PURE__*/_jsxDEV(\"planeGeometry\", {\n        attach: \"geometry\",\n        args: [1000, 1000]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 64,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"meshStandardMaterial\", {\n        attach: \"material\",\n        color: lightColor,\n        side: DoubleSide,\n        transparent: true,\n        opacity: 0.0\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 65,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 13\n    }, this);\n  }\n\n  _s4(BlurPlane, \"ON8hkDgRUJBfzQe1vB/Vo2D5zSM=\");\n\n  function Test(props) {\n    _s5();\n\n    const mesh = useRef(null); // let ogPosition = useRef<THREE.BufferAttribute | THREE.InterleavedBufferAttribute>(null!)\n\n    let ogGeo = useRef(null); // Saving original position as a reference\n\n    useEffect(() => {\n      // const { geometry } = mesh.current\n      // const { position } = geometry.attributes // vertices of geometry\n      // ogPosition.current = position // Saved here as mesh is not declared yet outside\n      const {\n        geometry\n      } = mesh.current;\n      ogGeo.current = geometry;\n    }, []); // Rotating animation\n\n    useFrame(_ref => {\n      let {\n        clock\n      } = _ref;\n      // const time = clock.getElapsedTime()\n      mesh.current.rotation.x -= 0.005;\n      mesh.current.rotation.y -= 0.01;\n    });\n    console.log('Render Check'); // Accessing vertices\n\n    useEffect(() => {// const { geometry } = mesh.current\n      // const { position } = geometry.attributes // vertices of geometry\n      // // WORKING\n      // console.log('ogGeo before')\n      // console.log(ogGeo.current.attributes.position)\n      // console.log('mesh before')\n      // console.log(mesh.current.geometry.attributes.position)\n      // let vertex = new THREE.Vector3()\n      // for (let i=0; i < 240; i++) {\n      //     vertex.fromBufferAttribute(ogGeo.current.attributes.position, i)\n      //     console.log('Vertex before:')\n      //     console.log(vertex)\n      //     console.log('Vertex X val')\n      //     console.log(vertex.x)\n      //     console.log(noise.simplex3(0.5, 1, 0.5))\n      //     let perlin = noise.simplex3(\n      //         (vertex.x * 0.9) + (6000000000), // xyz coeff affecting extreme spike appearences when closer to 1\n      //         (vertex.y * 0.9)+ (6000000000), // added term is just increasing time\n      //         (vertex.z * 0.9)+ (6000000000))\n      //     let scale = 1 + (perlin * 0.1) // perlin coefficient affecting drasticness of size change from 1\n      //     vertex.multiplyScalar(scale)\n      //     console.log('Vertex after')\n      //     console.log(vertex)\n      //     console.log('Vertex X val')\n      //     console.log(vertex.x)\n      //     mesh.current.geometry.attributes.position.setXYZ(i, vertex.x, vertex.y, vertex.z)\n      //     // mesh.current.geometry.attributes.position.needsUpdate = true\n      //     console.log(mesh.current.geometry.attributes.position.getX(i))\n      // }\n      // mesh.current.geometry.attributes.position.needsUpdate = true\n      // console.log('ogGeo after')\n      // console.log(ogGeo.current.attributes.position)\n      // console.log('mesh after')\n      // console.log(mesh.current.geometry.attributes.position)\n      // ogPosition.current = position // Held constant as an OG reference\n      // /// testing area\n      // const ogPos = ogPosition.current\n      // const newPos = mesh.current.geometry.getAttribute(\"position\"); // Current state\n      // const newPosArr = Float32Array.from(newPos.array) // Copy of Current\n      // console.log(\"-- START -- \")\n      // console.log('OG Array' + ogPos.array)    \n      // console.log('Mesh Current' + newPos.array)    \n      // console.log('Mesh Current Copy' + newPosArr.slice(0,5))\n      // for (let vertex=0; vertex<ogPos.count; vertex++) {\n      //     let x = ogPos.array[vertex*3] // Unlike THREE.vector3 types, vertices are not objects with .x.y.z\n      //     let y = ogPos.array[(vertex*3)+1] // three-fiber has the vertex values in one array\n      //     let z = ogPos.array[(vertex*3)+2]\n      //     let perlin = noise.simplex3(\n      //         (x*0.006) + (0 * 0.0005),\n      //         (y*0.006) + (0 * 0.0005),\n      //         (z*0.006)\n      //     )\n      //     let ratio = ((perlin * 0.3 *0.1) + 0.8)\n      //     newPosArr[vertex*3] = newPosArr[vertex*3] * ratio\n      //     newPosArr[(vertex*3)+1] = newPosArr[(vertex*3)+1] * ratio\n      //     newPosArr[(vertex*3)+2] = newPosArr[(vertex*3)+2] * ratio\n      // }\n      // console.log(\"-- After Loop -- \")\n      // console.log('OG Array' + ogPos.array)    \n      // console.log('Mesh Current' + newPos.array)    \n      // console.log('Mesh Current Copy' + newPosArr.slice(0,5))\n      // mesh.current.geometry.setAttribute('position', new THREE.BufferAttribute(newPosArr, 3));\n      // mesh.current.geometry.attributes.position.needsUpdate = true;\n      // const finalArr = mesh.current.geometry.getAttribute(\"position\").array\n      // console.log(finalArr)\n      // const ogPos = ogPosition.current\n      // const curPos = mesh.current.geometry.getAttribute(\"position\"); // Current position of mesh\n      // const newPosArr = Float32Array.from(ogPos.array) // Template of current position to be scaled\n      // console.log(newPosArr)\n      // for (let vertex=0; vertex<ogPos.count; vertex++) {\n      //     let x = ogPos.array[vertex*3] // Unlike THREE.vector3 types, vertices are not objects with .x.y.z\n      //     let y = ogPos.array[(vertex*3)+1] // three-fiber has the vertex values in one array\n      //     let z = ogPos.array[(vertex*3)+2]\n      //     let perlin = noise.simplex3(\n      //         (x*0.006) + (1 * 0.0002),\n      //         (y*0.006) + (1 * 0.0003),\n      //         (z*0.006)\n      //     )\n      //     let ratio = ((perlin * 0.3 ) + 1)\n      //     newPosArr[vertex*3] = newPosArr[vertex*3] * ratio\n      //     newPosArr[(vertex*3)+1] = newPosArr[(vertex*3)+1] * ratio\n      //     newPosArr[(vertex*3)+2] = newPosArr[(vertex*3)+2] * ratio\n      // }\n      // console.log(mesh.current.geometry.getAttribute('position'))\n      // mesh.current.geometry.setAttribute('position', new THREE.BufferAttribute(newPosArr, 3));\n      // mesh.current.geometry.attributes.position.needsUpdate = true;\n      // console.log(mesh.current.geometry.getAttribute('position'))\n      // console.log('Updated Mesh')\n    }, []);\n    useFrame(_ref2 => {\n      let {\n        clock\n      } = _ref2;\n      const time = clock.getElapsedTime();\n      const {\n        geometry\n      } = mesh.current;\n      const {\n        position\n      } = geometry.attributes; // vertices of geometry\n      // // WORKING part 1\n\n      let vertex = new THREE.Vector3();\n\n      for (let i = 0; i < ogGeo.current.attributes.position.count; i++) {\n        // vertex.fromBufferAttribute(ogGeo.current.attributes.position, i).setLength(1)\n        vertex.fromBufferAttribute(ogGeo.current.attributes.position, i);\n        let perlin = noise.simplex3(vertex.x * 0.7 + time, // xyz coeff affecting extreme spike appearences when closer to 1\n        vertex.y * 0.7 + time, // added term is just increasing time\n        vertex.z * 0.7 + time);\n        let scale = 1 + perlin * 0.0005; // perlin coefficient affecting drasticness of size change from 1\n\n        vertex.fromBufferAttribute(ogGeo.current.attributes.position, i);\n        vertex.multiplyScalar(scale); // keeps increasing or decreasing by scale for some reason\n        // vertex.setLength(scale)\n\n        position.setXYZ(i, vertex.x, vertex.y, vertex.z);\n        position.needsUpdate = true;\n      }\n\n      geometry.computeVertexNormals(); // ver alpha\n      // let vertex = new THREE.Vector3()\n      // for (let i=0; i < 240; i++) {\n      //     vertex.fromBufferAttribute(ogGeo.current.attributes.position, i)\n      //     let perlin = noise.simplex3(\n      //         (vertex.x * 0.9) + (time * 0.002), // xyz coeff affecting extreme spike appearences when closer to 1\n      //         (vertex.y * 0.9)+ (time * 0.002), // added term is just increasing time\n      //         (vertex.z * 0.9)+ (time * 0.002))\n      //     let scale = 1 + (perlin * 0.001) // perlin coefficient affecting drasticness of size change from 1\n      //     vertex.multiplyScalar(scale)\n      //     mesh.current.geometry.attributes.position.setXYZ(i, vertex.x, vertex.y, vertex.z)\n      //     mesh.current.geometry.attributes.position.needsUpdate = true\n      //     console.log(mesh.current.geometry.attributes.position.getX(i))\n      // }\n      // ver one\n      // const ogPos = ogPosition.current\n      // const curPos = mesh.current.geometry.getAttribute(\"position\"); // Current position of mesh\n      // const newPosArr = Float32Array.from(ogPos.array) // Template of current position to be scaled\n      // for (let vertex=0; vertex<(ogPos.count-3); vertex++) {\n      //     let x = ogPos.array[vertex*3] // Unlike THREE.vector3 types, vertices are not objects with .x.y.z\n      //     let y = ogPos.array[(vertex*3)+1] // three-fiber has the vertex values in one array\n      //     let z = ogPos.array[(vertex*3)+2]\n      //     let perlin = noise.simplex3(\n      //         (x*0.006) + (time * 0.002),\n      //         (y*0.006) + (time * 0.003),\n      //         (z*0.006)\n      //     )\n      //     let ratio = ((perlin * 0.3 ) + 1)\n      //     newPosArr[vertex*3] = ogPos.array[vertex*3] * ratio\n      //     newPosArr[(vertex*3)+1] = ogPos.array[(vertex*3)+1] * ratio\n      //     newPosArr[(vertex*3)+2] = ogPos.array[(vertex*3)+2] * ratio\n      // }\n      // mesh.current.geometry.setAttribute('position', new THREE.BufferAttribute(newPosArr, 3));\n      // mesh.current.geometry.attributes.position.needsUpdate = true;\n      // console.log('Updated Mesh')\n      // ver two\n      // let v3 = new THREE.Vector3()\n      // for (let i=0; i < position.count; i++) {\n      //     v3.fromBufferAttribute(position, i).setLength(3)\n      //     let perlin = noise.simplex3(v3.x + time, v3.y + time, v3.z + time)\n      //     v3.setLength(1 + 0.3 * 3)\n      //     position.setXYZ(i, v3.x, v3.y, v3.z)\n      // }\n      // position.needsUpdate = true;\n      // geometry.computeVertexNormals();\n      // ver three\n      // const ogPos = ogPosition.current\n      // const curPos = geometry.getAttribute('position')\n      // for ( let vertIndex = 0; vertIndex < curPos.count; vertIndex++ ) {\n      //     let vertex = new THREE.Vector3()\n      //     vertex.fromBufferAttribute( ogPos, vertIndex )\n      //     let perlin = noise.simplex3(\n      //         (vertex.x * 0.006) + (time * 0.0002),\n      //         (vertex.y * 0.006) + (time * 0.0003),\n      //         (vertex.z * 0.006)\n      //     )\n      //     let ratio = 1 + (perlin * 0.4)\n      //     vertex.multiplyScalar( ratio )\n      //     mesh.current.geometry.attributes.position.setXYZ(vertIndex, vertex.x, vertex.y, vertex.z)\n      // }\n      // position.needsUpdate = true\n      // console.log('UPdated mesh')\n    });\n    return /*#__PURE__*/_jsxDEV(\"mesh\", { ...props,\n      ref: mesh,\n      castShadow: true,\n      receiveShadow: false,\n      children: [/*#__PURE__*/_jsxDEV(\"sphereBufferGeometry\", {\n        args: [1, 128, 128]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 301,\n        columnNumber: 13\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"meshStandardMaterial\", {\n        color: 0xB5D5FE,\n        roughness: 0.6,\n        metalness: 0.2,\n        wireframe: false,\n        side: FrontSide\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 302,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 296,\n      columnNumber: 11\n    }, this);\n  }\n\n  _s5(Test, \"BWGtQSb/5QiUUyj8/tdC3Pd5+z4=\", false, function () {\n    return [useFrame, useFrame];\n  });\n\n  function Blob(props) {\n    _s6();\n\n    const mesh = useRef(null);\n    let ogGeo = useRef(null); // Saving original position as a reference\n\n    useEffect(() => {\n      const {\n        geometry\n      } = mesh.current;\n      ogGeo.current = geometry;\n    }, []); // Rotating animation\n\n    useFrame(() => {\n      mesh.current.rotation.x += 0.005;\n      mesh.current.rotation.y -= 0.005;\n    }); // Perlin noise animation\n\n    useFrame(_ref3 => {\n      let {\n        clock\n      } = _ref3;\n      const time = clock.getElapsedTime(); // For incrementing perlin noise calc\n\n      const {\n        geometry\n      } = mesh.current;\n      const {\n        position\n      } = geometry.attributes; // to access vertices of geometry\n\n      let vertex = new THREE.Vector3(); // placeholder for new vertex vals\n\n      for (let i = 0; i < ogGeo.current.attributes.position.count; i++) {\n        vertex.fromBufferAttribute(ogGeo.current.attributes.position, i); // copying original geometry\n\n        let perlin = noise.simplex3(vertex.x * 0.9 + time * 0.4, // vertex coeffs __\n        vertex.y * 0.9 + time * 0.4, // time component will affect incrementing steps and spike variance\n        vertex.z * 0.9 + time * 0.4);\n        let ratio = 1 + perlin * 0.0005; // perlin ceoff affects range of change from baseline 1\n\n        vertex.multiplyScalar(ratio);\n        position.setXYZ(i, vertex.x, vertex.y, vertex.z);\n        position.needsUpdate = true;\n      }\n\n      geometry.computeVertexNormals();\n    });\n    return /*#__PURE__*/_jsxDEV(\"mesh\", { ...props,\n      ref: mesh,\n      castShadow: true,\n      receiveShadow: false,\n      children: [/*#__PURE__*/_jsxDEV(\"sphereBufferGeometry\", {\n        args: [1.4, 256, 156]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 355,\n        columnNumber: 13\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"meshStandardMaterial\", {\n        color: 0xB5D5FE,\n        roughness: 0.6,\n        metalness: 0.2,\n        wireframe: false,\n        side: FrontSide\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 356,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 350,\n      columnNumber: 11\n    }, this);\n  }\n\n  _s6(Blob, \"0/1b1FqFrNEToY+rfZesYITnzyk=\", false, function () {\n    return [useFrame, useFrame];\n  });\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"bg\",\n    id: \"canvas-container\",\n    children: /*#__PURE__*/_jsxDEV(Canvas, {\n      shadows: true,\n      children: [/*#__PURE__*/_jsxDEV(\"pointLight\", {\n        intensity: 0.3,\n        position: [150, 150, 15]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 373,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"directionalLight\", {\n        color: 0x0099FA,\n        intensity: 0.8,\n        position: [0, 350, 350],\n        castShadow: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 374,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"directionalLight\", {\n        color: 0x62C7B7,\n        intensity: 0.4,\n        position: [-300, 400, 350]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 375,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"directionalLight\", {\n        color: 0x62C7B7,\n        intensity: 0.2,\n        position: [0, -250, 300]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 376,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"hemisphereLight\", {\n        color: 0xffffff,\n        groundColor: 0x000000,\n        intensity: 0.8\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 377,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(BackgroundPlane, {\n        position: [0, 0, -100]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 380,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(BlurPlane, {\n        position: [0, 0, 3]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 381,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Blob, {\n        position: [1, 0, 0]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 382,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 369,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 367,\n    columnNumber: 9\n  }, this);\n}\n_c = BackgroundCanvas;\n\nvar _c;\n\n$RefreshReg$(_c, \"BackgroundCanvas\");","map":{"version":3,"sources":["/Users/lawrencehan/Documents/GitHub/hanlarry/src/components/background/BackgroundCanvas.tsx"],"names":["React","useRef","useEffect","THREE","DoubleSide","FrontSide","Canvas","useFrame","noise","BackgroundCanvas","props","darkMode","darkColor","lightColor","Sphere","mesh","state","delta","current","rotation","x","y","Skeleton","BackgroundPlane","meshPlane","BlurPlane","Test","ogGeo","geometry","clock","console","log","time","getElapsedTime","position","attributes","vertex","Vector3","i","count","fromBufferAttribute","perlin","simplex3","z","scale","multiplyScalar","setXYZ","needsUpdate","computeVertexNormals","Blob","ratio"],"mappings":";AAAA,OAAOA,KAAP,IAA0BC,MAA1B,EAAkCC,SAAlC,QAA4D,OAA5D;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,EAAqBC,SAArB,QAAsC,OAAtC;AACA,SAASC,MAAT,EAAiBC,QAAjB,QAAiC,oBAAjC;AACA,OAAO,kBAAP;AACA,SAASC,KAAT,QAAsB,cAAtB;;AAKA,eAAe,SAASC,gBAAT,CAA0BC,KAA1B,EAA0C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACrD,QAAM;AAAEC,IAAAA;AAAF,MAAeD,KAArB;AACA,QAAM,CAACE,SAAD,EAAYC,UAAZ,IAA0B,CAAC,QAAD,EAAW,QAAX,CAAhC,CAFqD,CAIrD;;AACA,WAASC,MAAT,CAAgBJ,KAAhB,EAAsD;AAAA;;AAClD,UAAMK,IAAI,GAAGd,MAAM,CAAa,IAAb,CAAnB;AACAM,IAAAA,QAAQ,CAAC,CAACS,KAAD,EAAQC,KAAR,KAAmBF,IAAI,CAACG,OAAL,CAAaC,QAAb,CAAsBC,CAAtB,IAA2B,IAA/C,CAAR;AACAb,IAAAA,QAAQ,CAAC,CAACS,KAAD,EAAQC,KAAR,KAAmBF,IAAI,CAACG,OAAL,CAAaC,QAAb,CAAsBE,CAAtB,IAA2B,IAA/C,CAAR;AACA,wBACE,qBACMX,KADN;AAEE,MAAA,GAAG,EAAEK,IAFP;AAAA,8BAGE;AAAgB,QAAA,IAAI,EAAE,CAAC,CAAD,EAAG,GAAH,EAAO,GAAP;AAAtB;AAAA;AAAA;AAAA;AAAA,cAHF,oBAIE;AAAA;AAAA;AAAA;AAAA,cAJF;AAAA;AAAA;AAAA;AAAA;AAAA,YADF;AAQH;;AAjBoD,KAK5CD,MAL4C;AAAA,YAOjDP,QAPiD,EAQjDA,QARiD;AAAA;;AAkBrD,WAASe,QAAT,CAAkBZ,KAAlB,EAAwD;AAAA;;AACpD,UAAMK,IAAI,GAAGd,MAAM,CAAa,IAAb,CAAnB;AACAM,IAAAA,QAAQ,CAAC,CAACS,KAAD,EAAQC,KAAR,KAAmBF,IAAI,CAACG,OAAL,CAAaC,QAAb,CAAsBC,CAAtB,IAA2B,KAA/C,CAAR;AACAb,IAAAA,QAAQ,CAAC,CAACS,KAAD,EAAQC,KAAR,KAAmBF,IAAI,CAACG,OAAL,CAAaC,QAAb,CAAsBE,CAAtB,IAA2B,KAA/C,CAAR;AACA,wBACI,qBACQX,KADR;AAEI,MAAA,GAAG,EAAEK,IAFT;AAAA,8BAGI;AAAqB,QAAA,IAAI,EAAE,CAAC,GAAD,EAAM,CAAN;AAA3B;AAAA;AAAA;AAAA;AAAA,cAHJ,qBAII;AAAmB,QAAA,KAAK,EAAC,SAAzB;AAAmC,QAAA,SAAS,EAAE,IAA9C;AAAoD,QAAA,kBAAkB,EAAE,GAAxE;AAA6E,QAAA,IAAI,EAAEX;AAAnF;AAAA;AAAA;AAAA;AAAA,cAJJ;AAAA;AAAA;AAAA;AAAA;AAAA,YADJ;AAQH;;AA9BoD,MAkB5CkB,QAlB4C;AAAA,YAoBjDf,QApBiD,EAqBjDA,QArBiD;AAAA;;AA+BrD,WAASgB,eAAT,CAAyBb,KAAzB,EAA+D;AAAA;;AAC3D,UAAMc,SAAS,GAAGvB,MAAM,CAAa,IAAb,CAAxB;AACA,wBACI,qBACQS,KADR;AAEI,MAAA,aAAa,MAFjB;AAGI,MAAA,GAAG,EAAEc,SAHT;AAAA,8BAII;AAAe,QAAA,MAAM,EAAC,UAAtB;AAAiC,QAAA,IAAI,EAAE,CAAC,IAAD,EAAO,IAAP;AAAvC;AAAA;AAAA;AAAA;AAAA,cAJJ,eAKI;AAAsB,QAAA,MAAM,EAAC,UAA7B;AAAwC,QAAA,KAAK,EAAEb,QAAQ,GAAGC,SAAH,GAAaC,UAApE;AAAgF,QAAA,IAAI,EAAET,UAAtF;AAAkG,QAAA,WAAW,EAAE,IAA/G;AAAqH,QAAA,OAAO,EAAE;AAA9H;AAAA;AAAA;AAAA;AAAA,cALJ;AAAA;AAAA;AAAA;AAAA;AAAA,YADJ;AASH;;AA1CoD,MA+B5CmB,eA/B4C;;AA2CrD,WAASE,SAAT,CAAmBf,KAAnB,EAAyD;AAAA;;AACrD,UAAMc,SAAS,GAAGvB,MAAM,CAAa,IAAb,CAAxB;AACAC,IAAAA,SAAS,CAAC,MAAM,CACZ;AACH,KAFQ,CAAT;AAIA,wBACI,qBACQQ,KADR;AAEI,MAAA,GAAG,EAAEc,SAFT;AAAA,8BAGI;AAAe,QAAA,MAAM,EAAC,UAAtB;AAAiC,QAAA,IAAI,EAAE,CAAC,IAAD,EAAO,IAAP;AAAvC;AAAA;AAAA;AAAA;AAAA,cAHJ,eAII;AAAsB,QAAA,MAAM,EAAC,UAA7B;AAAwC,QAAA,KAAK,EAAEX,UAA/C;AAA2D,QAAA,IAAI,EAAET,UAAjE;AAA6E,QAAA,WAAW,EAAE,IAA1F;AAAgG,QAAA,OAAO,EAAE;AAAzG;AAAA;AAAA;AAAA;AAAA,cAJJ;AAAA;AAAA;AAAA;AAAA;AAAA,YADJ;AAQH;;AAzDoD,MA2C5CqB,SA3C4C;;AA2DrD,WAASC,IAAT,CAAchB,KAAd,EAAoD;AAAA;;AAChD,UAAMK,IAAI,GAAGd,MAAM,CAAa,IAAb,CAAnB,CADgD,CAEhD;;AACA,QAAI0B,KAAK,GAAG1B,MAAM,CAAuB,IAAvB,CAAlB,CAHgD,CAKhD;;AACAC,IAAAA,SAAS,CAAC,MAAM;AACZ;AACA;AACA;AACA,YAAM;AAAE0B,QAAAA;AAAF,UAAeb,IAAI,CAACG,OAA1B;AACAS,MAAAA,KAAK,CAACT,OAAN,GAAgBU,QAAhB;AACH,KANQ,EAMN,EANM,CAAT,CANgD,CAehD;;AACArB,IAAAA,QAAQ,CAAC,QAAe;AAAA,UAAd;AAAEsB,QAAAA;AAAF,OAAc;AACpB;AACAd,MAAAA,IAAI,CAACG,OAAL,CAAaC,QAAb,CAAsBC,CAAtB,IAA2B,KAA3B;AACAL,MAAAA,IAAI,CAACG,OAAL,CAAaC,QAAb,CAAsBE,CAAtB,IAA2B,IAA3B;AACH,KAJO,CAAR;AAKAS,IAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ,EArBgD,CAsBhD;;AACA7B,IAAAA,SAAS,CAAC,MAAM,CACZ;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGH,KAlGQ,EAkGN,EAlGM,CAAT;AAoGAK,IAAAA,QAAQ,CAAC,SAAe;AAAA,UAAd;AAAEsB,QAAAA;AAAF,OAAc;AACpB,YAAMG,IAAI,GAAGH,KAAK,CAACI,cAAN,EAAb;AACA,YAAM;AAAEL,QAAAA;AAAF,UAAeb,IAAI,CAACG,OAA1B;AACA,YAAM;AAAEgB,QAAAA;AAAF,UAAeN,QAAQ,CAACO,UAA9B,CAHoB,CAGqB;AAEzC;;AACA,UAAIC,MAAM,GAAG,IAAIjC,KAAK,CAACkC,OAAV,EAAb;;AAEA,WAAK,IAAIC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAGX,KAAK,CAACT,OAAN,CAAciB,UAAd,CAAyBD,QAAzB,CAAkCK,KAApD,EAA2DD,CAAC,EAA5D,EAAgE;AAC5D;AACAF,QAAAA,MAAM,CAACI,mBAAP,CAA2Bb,KAAK,CAACT,OAAN,CAAciB,UAAd,CAAyBD,QAApD,EAA8DI,CAA9D;AACA,YAAIG,MAAM,GAAGjC,KAAK,CAACkC,QAAN,CACRN,MAAM,CAAChB,CAAP,GAAW,GAAZ,GAAoBY,IADX,EACkB;AAC1BI,QAAAA,MAAM,CAACf,CAAP,GAAW,GAAZ,GAAmBW,IAFV,EAEiB;AACzBI,QAAAA,MAAM,CAACO,CAAP,GAAW,GAAZ,GAAmBX,IAHV,CAAb;AAIA,YAAIY,KAAK,GAAG,IAAKH,MAAM,GAAG,MAA1B,CAP4D,CAO1B;;AAClCL,QAAAA,MAAM,CAACI,mBAAP,CAA2Bb,KAAK,CAACT,OAAN,CAAciB,UAAd,CAAyBD,QAApD,EAA8DI,CAA9D;AACAF,QAAAA,MAAM,CAACS,cAAP,CAAsBD,KAAtB,EAT4D,CAS/B;AAC7B;;AACAV,QAAAA,QAAQ,CAACY,MAAT,CAAgBR,CAAhB,EAAmBF,MAAM,CAAChB,CAA1B,EAA6BgB,MAAM,CAACf,CAApC,EAAuCe,MAAM,CAACO,CAA9C;AACAT,QAAAA,QAAQ,CAACa,WAAT,GAAuB,IAAvB;AACH;;AACDnB,MAAAA,QAAQ,CAACoB,oBAAT,GAtBoB,CA+BpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEH,KArGO,CAAR;AAsGA,wBACE,qBACMtC,KADN;AAEE,MAAA,GAAG,EAAEK,IAFP;AAGE,MAAA,UAAU,MAHZ;AAIE,MAAA,aAAa,EAAE,KAJjB;AAAA,8BAKE;AAAsB,QAAA,IAAI,EAAE,CAAC,CAAD,EAAG,GAAH,EAAO,GAAP;AAA5B;AAAA;AAAA;AAAA;AAAA,cALF,oBAME;AACI,QAAA,KAAK,EAAE,QADX;AAEI,QAAA,SAAS,EAAE,GAFf;AAGI,QAAA,SAAS,EAAE,GAHf;AAII,QAAA,SAAS,EAAE,KAJf;AAKI,QAAA,IAAI,EAAEV;AALV;AAAA;AAAA;AAAA;AAAA,cANF;AAAA;AAAA;AAAA;AAAA;AAAA,YADF;AAeH;;AA3SoD,MA2D5CqB,IA3D4C;AAAA,YA2EjDnB,QA3EiD,EAsLjDA,QAtLiD;AAAA;;AA6SrD,WAAS0C,IAAT,CAAcvC,KAAd,EAAoD;AAAA;;AAChD,UAAMK,IAAI,GAAGd,MAAM,CAAa,IAAb,CAAnB;AACA,QAAI0B,KAAK,GAAG1B,MAAM,CAAuB,IAAvB,CAAlB,CAFgD,CAIhD;;AACAC,IAAAA,SAAS,CAAC,MAAM;AACZ,YAAM;AAAE0B,QAAAA;AAAF,UAAeb,IAAI,CAACG,OAA1B;AACAS,MAAAA,KAAK,CAACT,OAAN,GAAgBU,QAAhB;AACH,KAHQ,EAGN,EAHM,CAAT,CALgD,CAWhD;;AACArB,IAAAA,QAAQ,CAAC,MAAM;AACXQ,MAAAA,IAAI,CAACG,OAAL,CAAaC,QAAb,CAAsBC,CAAtB,IAA2B,KAA3B;AACAL,MAAAA,IAAI,CAACG,OAAL,CAAaC,QAAb,CAAsBE,CAAtB,IAA2B,KAA3B;AACH,KAHO,CAAR,CAZgD,CAiBhD;;AACAd,IAAAA,QAAQ,CAAC,SAAe;AAAA,UAAd;AAAEsB,QAAAA;AAAF,OAAc;AACpB,YAAMG,IAAI,GAAGH,KAAK,CAACI,cAAN,EAAb,CADoB,CACgB;;AACpC,YAAM;AAAEL,QAAAA;AAAF,UAAeb,IAAI,CAACG,OAA1B;AACA,YAAM;AAAEgB,QAAAA;AAAF,UAAeN,QAAQ,CAACO,UAA9B,CAHoB,CAGqB;;AAEzC,UAAIC,MAAM,GAAG,IAAIjC,KAAK,CAACkC,OAAV,EAAb,CALoB,CAKa;;AACjC,WAAK,IAAIC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAGX,KAAK,CAACT,OAAN,CAAciB,UAAd,CAAyBD,QAAzB,CAAkCK,KAApD,EAA2DD,CAAC,EAA5D,EAAgE;AAC5DF,QAAAA,MAAM,CAACI,mBAAP,CAA2Bb,KAAK,CAACT,OAAN,CAAciB,UAAd,CAAyBD,QAApD,EAA8DI,CAA9D,EAD4D,CACK;;AACjE,YAAIG,MAAM,GAAGjC,KAAK,CAACkC,QAAN,CACRN,MAAM,CAAChB,CAAP,GAAW,GAAZ,GAAoBY,IAAI,GAAG,GADlB,EACwB;AAChCI,QAAAA,MAAM,CAACf,CAAP,GAAW,GAAZ,GAAmBW,IAAI,GAAG,GAFjB,EAEuB;AAC/BI,QAAAA,MAAM,CAACO,CAAP,GAAW,GAAZ,GAAmBX,IAAI,GAAG,GAHjB,CAAb;AAIA,YAAIkB,KAAK,GAAG,IAAKT,MAAM,GAAG,MAA1B,CAN4D,CAM1B;;AAClCL,QAAAA,MAAM,CAACS,cAAP,CAAsBK,KAAtB;AACAhB,QAAAA,QAAQ,CAACY,MAAT,CAAgBR,CAAhB,EAAmBF,MAAM,CAAChB,CAA1B,EAA6BgB,MAAM,CAACf,CAApC,EAAuCe,MAAM,CAACO,CAA9C;AACAT,QAAAA,QAAQ,CAACa,WAAT,GAAuB,IAAvB;AACH;;AACDnB,MAAAA,QAAQ,CAACoB,oBAAT;AACH,KAlBO,CAAR;AAmBA,wBACE,qBACMtC,KADN;AAEE,MAAA,GAAG,EAAEK,IAFP;AAGE,MAAA,UAAU,MAHZ;AAIE,MAAA,aAAa,EAAE,KAJjB;AAAA,8BAKE;AAAsB,QAAA,IAAI,EAAE,CAAE,GAAF,EAAO,GAAP,EAAY,GAAZ;AAA5B;AAAA;AAAA;AAAA;AAAA,cALF,oBAME;AACI,QAAA,KAAK,EAAE,QADX;AAEI,QAAA,SAAS,EAAE,GAFf;AAGI,QAAA,SAAS,EAAE,GAHf;AAII,QAAA,SAAS,EAAE,KAJf;AAKI,QAAA,IAAI,EAAEV;AALV;AAAA;AAAA;AAAA;AAAA,cANF;AAAA;AAAA;AAAA;AAAA;AAAA,YADF;AAeH;;AAjWoD,MA6S5C4C,IA7S4C;AAAA,YAyTjD1C,QAzTiD,EA+TjDA,QA/TiD;AAAA;;AAmWrD,sBACI;AAAK,IAAA,SAAS,EAAC,IAAf;AAAoB,IAAA,EAAE,EAAC,kBAAvB;AAAA,2BAEI,QAAC,MAAD;AACA,MAAA,OAAO,MADP;AAAA,8BAII;AAAY,QAAA,SAAS,EAAE,GAAvB;AAA4B,QAAA,QAAQ,EAAE,CAAC,GAAD,EAAM,GAAN,EAAW,EAAX;AAAtC;AAAA;AAAA;AAAA;AAAA,cAJJ,eAKI;AAAkB,QAAA,KAAK,EAAG,QAA1B;AAAqC,QAAA,SAAS,EAAG,GAAjD;AAAuD,QAAA,QAAQ,EAAE,CAAE,CAAF,EAAK,GAAL,EAAU,GAAV,CAAjE;AAAkF,QAAA,UAAU,EAAE;AAA9F;AAAA;AAAA;AAAA;AAAA,cALJ,eAMI;AAAkB,QAAA,KAAK,EAAI,QAA3B;AAAsC,QAAA,SAAS,EAAG,GAAlD;AAAwD,QAAA,QAAQ,EAAE,CAAE,CAAC,GAAH,EAAQ,GAAR,EAAa,GAAb;AAAlE;AAAA;AAAA;AAAA;AAAA,cANJ,eAOI;AAAkB,QAAA,KAAK,EAAI,QAA3B;AAAsC,QAAA,SAAS,EAAG,GAAlD;AAAwD,QAAA,QAAQ,EAAE,CAAE,CAAF,EAAK,CAAC,GAAN,EAAW,GAAX;AAAlE;AAAA;AAAA;AAAA;AAAA,cAPJ,eAQI;AAAiB,QAAA,KAAK,EAAG,QAAzB;AAAoC,QAAA,WAAW,EAAG,QAAlD;AAA6D,QAAA,SAAS,EAAG;AAAzE;AAAA;AAAA;AAAA;AAAA,cARJ,eAWI,QAAC,eAAD;AAAiB,QAAA,QAAQ,EAAE,CAAE,CAAF,EAAK,CAAL,EAAQ,CAAC,GAAT;AAA3B;AAAA;AAAA;AAAA;AAAA,cAXJ,eAYI,QAAC,SAAD;AAAW,QAAA,QAAQ,EAAE,CAAE,CAAF,EAAK,CAAL,EAAQ,CAAR;AAArB;AAAA;AAAA;AAAA;AAAA,cAZJ,eAaI,QAAC,IAAD;AAAM,QAAA,QAAQ,EAAE,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL;AAAhB;AAAA;AAAA;AAAA;AAAA,cAbJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAFJ;AAAA;AAAA;AAAA;AAAA,UADJ;AAoBH;KAvXuBE,gB","sourcesContent":["import React, { useState, useRef, useEffect, useMemo } from 'react';\nimport * as THREE from 'three';\nimport { DoubleSide, FrontSide } from 'three';\nimport { Canvas, useFrame } from '@react-three/fiber';\nimport './background.css';\nimport { noise } from '../../Perlin';\ninterface bgCanvas {\n    darkMode: boolean;\n}\n\nexport default function BackgroundCanvas(props:bgCanvas) {\n    const { darkMode } = props\n    const [darkColor, lightColor] = [0x2A2B2A, 0xFCF7FF]\n    \n    // When forming a MESH with useFrame(), it must be its own component, outside of App()\n    function Sphere(props: JSX.IntrinsicElements['mesh']) {\n        const mesh = useRef<THREE.Mesh>(null!)\n        useFrame((state, delta) => (mesh.current.rotation.x += 0.01))\n        useFrame((state, delta) => (mesh.current.rotation.y += 0.01))\n        return (\n          <mesh\n            {...props}\n            ref={mesh}>\n            <sphereGeometry args={[1,128,128]} /> {/* radius, widthSeg, heightSeg */}\n            <meshNormalMaterial />\n          </mesh>\n        )\n    }\n    function Skeleton(props: JSX.IntrinsicElements['mesh']) {\n        const mesh = useRef<THREE.Mesh>(null!)\n        useFrame((state, delta) => (mesh.current.rotation.x -= 0.005))\n        useFrame((state, delta) => (mesh.current.rotation.y -= 0.005))\n        return (\n            <mesh\n                {...props}\n                ref={mesh}>\n                <icosahedronGeometry args={[1.5, 2]} />  {/* radius, detail */}\n                <meshPhongMaterial color=\"#ffffff\" wireframe={true} wireframeLinewidth={200} side={DoubleSide} />\n            </mesh>\n        )\n    }\n    function BackgroundPlane(props: JSX.IntrinsicElements['mesh']) {\n        const meshPlane = useRef<THREE.Mesh>(null!)\n        return (\n            <mesh\n                {...props}\n                receiveShadow\n                ref={meshPlane}>\n                <planeGeometry attach=\"geometry\" args={[1000, 1000]} />\n                <meshStandardMaterial attach=\"material\" color={darkMode ? darkColor:lightColor} side={DoubleSide} transparent={true} opacity={0.3} />\n            </mesh>\n        )\n    }\n    function BlurPlane(props: JSX.IntrinsicElements['mesh']) {\n        const meshPlane = useRef<THREE.Mesh>(null!)\n        useEffect(() => {\n            // meshPlane.current.rotation.x = Math.PI / 4 * -1\n        })\n\n        return (\n            <mesh\n                {...props}\n                ref={meshPlane}>\n                <planeGeometry attach=\"geometry\" args={[1000, 1000]} />\n                <meshStandardMaterial attach=\"material\" color={lightColor} side={DoubleSide} transparent={true} opacity={0.0} />\n            </mesh>\n        )\n    }\n\n    function Test(props: JSX.IntrinsicElements['mesh']) {\n        const mesh = useRef<THREE.Mesh>(null!)\n        // let ogPosition = useRef<THREE.BufferAttribute | THREE.InterleavedBufferAttribute>(null!)\n        let ogGeo = useRef<THREE.BufferGeometry>(null!)\n\n        // Saving original position as a reference\n        useEffect(() => {\n            // const { geometry } = mesh.current\n            // const { position } = geometry.attributes // vertices of geometry\n            // ogPosition.current = position // Saved here as mesh is not declared yet outside\n            const { geometry } = mesh.current\n            ogGeo.current = geometry  \n        }, [])\n\n\n        // Rotating animation\n        useFrame(({ clock }) => {\n            // const time = clock.getElapsedTime()\n            mesh.current.rotation.x -= 0.005\n            mesh.current.rotation.y -= 0.01\n        })\n        console.log('Render Check')\n        // Accessing vertices\n        useEffect(() => {\n            // const { geometry } = mesh.current\n            // const { position } = geometry.attributes // vertices of geometry\n\n            // // WORKING\n            // console.log('ogGeo before')\n            // console.log(ogGeo.current.attributes.position)\n            // console.log('mesh before')\n            // console.log(mesh.current.geometry.attributes.position)\n            // let vertex = new THREE.Vector3()\n            // for (let i=0; i < 240; i++) {\n            //     vertex.fromBufferAttribute(ogGeo.current.attributes.position, i)\n            //     console.log('Vertex before:')\n            //     console.log(vertex)\n            //     console.log('Vertex X val')\n            //     console.log(vertex.x)\n            //     console.log(noise.simplex3(0.5, 1, 0.5))\n            //     let perlin = noise.simplex3(\n            //         (vertex.x * 0.9) + (6000000000), // xyz coeff affecting extreme spike appearences when closer to 1\n            //         (vertex.y * 0.9)+ (6000000000), // added term is just increasing time\n            //         (vertex.z * 0.9)+ (6000000000))\n            //     let scale = 1 + (perlin * 0.1) // perlin coefficient affecting drasticness of size change from 1\n            //     vertex.multiplyScalar(scale)\n            //     console.log('Vertex after')\n            //     console.log(vertex)\n            //     console.log('Vertex X val')\n            //     console.log(vertex.x)\n\n            //     mesh.current.geometry.attributes.position.setXYZ(i, vertex.x, vertex.y, vertex.z)\n            //     // mesh.current.geometry.attributes.position.needsUpdate = true\n            //     console.log(mesh.current.geometry.attributes.position.getX(i))\n            // }\n            // mesh.current.geometry.attributes.position.needsUpdate = true\n            // console.log('ogGeo after')\n            // console.log(ogGeo.current.attributes.position)\n            // console.log('mesh after')\n            // console.log(mesh.current.geometry.attributes.position)\n            \n\n            // ogPosition.current = position // Held constant as an OG reference\n\n            // /// testing area\n            // const ogPos = ogPosition.current\n            // const newPos = mesh.current.geometry.getAttribute(\"position\"); // Current state\n            // const newPosArr = Float32Array.from(newPos.array) // Copy of Current\n            // console.log(\"-- START -- \")\n            // console.log('OG Array' + ogPos.array)    \n            // console.log('Mesh Current' + newPos.array)    \n            // console.log('Mesh Current Copy' + newPosArr.slice(0,5))\n            // for (let vertex=0; vertex<ogPos.count; vertex++) {\n            //     let x = ogPos.array[vertex*3] // Unlike THREE.vector3 types, vertices are not objects with .x.y.z\n            //     let y = ogPos.array[(vertex*3)+1] // three-fiber has the vertex values in one array\n            //     let z = ogPos.array[(vertex*3)+2]\n            //     let perlin = noise.simplex3(\n            //         (x*0.006) + (0 * 0.0005),\n            //         (y*0.006) + (0 * 0.0005),\n            //         (z*0.006)\n            //     )\n            //     let ratio = ((perlin * 0.3 *0.1) + 0.8)\n            //     newPosArr[vertex*3] = newPosArr[vertex*3] * ratio\n            //     newPosArr[(vertex*3)+1] = newPosArr[(vertex*3)+1] * ratio\n            //     newPosArr[(vertex*3)+2] = newPosArr[(vertex*3)+2] * ratio\n            // }\n            // console.log(\"-- After Loop -- \")\n            // console.log('OG Array' + ogPos.array)    \n            // console.log('Mesh Current' + newPos.array)    \n            // console.log('Mesh Current Copy' + newPosArr.slice(0,5))\n            // mesh.current.geometry.setAttribute('position', new THREE.BufferAttribute(newPosArr, 3));\n            // mesh.current.geometry.attributes.position.needsUpdate = true;\n            // const finalArr = mesh.current.geometry.getAttribute(\"position\").array\n            // console.log(finalArr)\n\n            // const ogPos = ogPosition.current\n            // const curPos = mesh.current.geometry.getAttribute(\"position\"); // Current position of mesh\n            // const newPosArr = Float32Array.from(ogPos.array) // Template of current position to be scaled\n            // console.log(newPosArr)\n            // for (let vertex=0; vertex<ogPos.count; vertex++) {\n            //     let x = ogPos.array[vertex*3] // Unlike THREE.vector3 types, vertices are not objects with .x.y.z\n            //     let y = ogPos.array[(vertex*3)+1] // three-fiber has the vertex values in one array\n            //     let z = ogPos.array[(vertex*3)+2]\n            //     let perlin = noise.simplex3(\n            //         (x*0.006) + (1 * 0.0002),\n            //         (y*0.006) + (1 * 0.0003),\n            //         (z*0.006)\n            //     )\n                \n            //     let ratio = ((perlin * 0.3 ) + 1)\n            //     newPosArr[vertex*3] = newPosArr[vertex*3] * ratio\n            //     newPosArr[(vertex*3)+1] = newPosArr[(vertex*3)+1] * ratio\n            //     newPosArr[(vertex*3)+2] = newPosArr[(vertex*3)+2] * ratio\n            // }\n            // console.log(mesh.current.geometry.getAttribute('position'))\n            // mesh.current.geometry.setAttribute('position', new THREE.BufferAttribute(newPosArr, 3));\n            // mesh.current.geometry.attributes.position.needsUpdate = true;\n            // console.log(mesh.current.geometry.getAttribute('position'))\n            // console.log('Updated Mesh')\n\n            \n        }, [])\n\n        useFrame(({ clock }) => {\n            const time = clock.getElapsedTime()\n            const { geometry } = mesh.current\n            const { position } = geometry.attributes // vertices of geometry\n\n            // // WORKING part 1\n            let vertex = new THREE.Vector3()\n            \n            for (let i=0; i < ogGeo.current.attributes.position.count; i++) {\n                // vertex.fromBufferAttribute(ogGeo.current.attributes.position, i).setLength(1)\n                vertex.fromBufferAttribute(ogGeo.current.attributes.position, i)\n                let perlin = noise.simplex3(\n                    (vertex.x * 0.7) + (time), // xyz coeff affecting extreme spike appearences when closer to 1\n                    (vertex.y * 0.7)+ (time), // added term is just increasing time\n                    (vertex.z * 0.7)+ (time))\n                let scale = 1 + (perlin * 0.0005) // perlin coefficient affecting drasticness of size change from 1\n                vertex.fromBufferAttribute(ogGeo.current.attributes.position, i)\n                vertex.multiplyScalar(scale) // keeps increasing or decreasing by scale for some reason\n                // vertex.setLength(scale)\n                position.setXYZ(i, vertex.x, vertex.y, vertex.z)\n                position.needsUpdate = true\n            }\n            geometry.computeVertexNormals();\n\n\n\n\n\n\n\n\n            // ver alpha\n            // let vertex = new THREE.Vector3()\n            // for (let i=0; i < 240; i++) {\n            //     vertex.fromBufferAttribute(ogGeo.current.attributes.position, i)\n            //     let perlin = noise.simplex3(\n            //         (vertex.x * 0.9) + (time * 0.002), // xyz coeff affecting extreme spike appearences when closer to 1\n            //         (vertex.y * 0.9)+ (time * 0.002), // added term is just increasing time\n            //         (vertex.z * 0.9)+ (time * 0.002))\n            //     let scale = 1 + (perlin * 0.001) // perlin coefficient affecting drasticness of size change from 1\n            //     vertex.multiplyScalar(scale)\n            //     mesh.current.geometry.attributes.position.setXYZ(i, vertex.x, vertex.y, vertex.z)\n            //     mesh.current.geometry.attributes.position.needsUpdate = true\n            //     console.log(mesh.current.geometry.attributes.position.getX(i))\n            // }\n\n            // ver one\n            // const ogPos = ogPosition.current\n            // const curPos = mesh.current.geometry.getAttribute(\"position\"); // Current position of mesh\n            // const newPosArr = Float32Array.from(ogPos.array) // Template of current position to be scaled\n            // for (let vertex=0; vertex<(ogPos.count-3); vertex++) {\n            //     let x = ogPos.array[vertex*3] // Unlike THREE.vector3 types, vertices are not objects with .x.y.z\n            //     let y = ogPos.array[(vertex*3)+1] // three-fiber has the vertex values in one array\n            //     let z = ogPos.array[(vertex*3)+2]\n            //     let perlin = noise.simplex3(\n            //         (x*0.006) + (time * 0.002),\n            //         (y*0.006) + (time * 0.003),\n            //         (z*0.006)\n            //     )\n            //     let ratio = ((perlin * 0.3 ) + 1)\n            //     newPosArr[vertex*3] = ogPos.array[vertex*3] * ratio\n            //     newPosArr[(vertex*3)+1] = ogPos.array[(vertex*3)+1] * ratio\n            //     newPosArr[(vertex*3)+2] = ogPos.array[(vertex*3)+2] * ratio\n            // }\n            // mesh.current.geometry.setAttribute('position', new THREE.BufferAttribute(newPosArr, 3));\n            // mesh.current.geometry.attributes.position.needsUpdate = true;\n            // console.log('Updated Mesh')\n\n            // ver two\n            // let v3 = new THREE.Vector3()\n            // for (let i=0; i < position.count; i++) {\n            //     v3.fromBufferAttribute(position, i).setLength(3)\n            //     let perlin = noise.simplex3(v3.x + time, v3.y + time, v3.z + time)\n            //     v3.setLength(1 + 0.3 * 3)\n            //     position.setXYZ(i, v3.x, v3.y, v3.z)\n            // }\n            // position.needsUpdate = true;\n            // geometry.computeVertexNormals();\n\n            // ver three\n            // const ogPos = ogPosition.current\n            // const curPos = geometry.getAttribute('position')\n            \n            // for ( let vertIndex = 0; vertIndex < curPos.count; vertIndex++ ) {\n            //     let vertex = new THREE.Vector3()\n            //     vertex.fromBufferAttribute( ogPos, vertIndex )\n\n            //     let perlin = noise.simplex3(\n            //         (vertex.x * 0.006) + (time * 0.0002),\n            //         (vertex.y * 0.006) + (time * 0.0003),\n            //         (vertex.z * 0.006)\n            //     )\n            //     let ratio = 1 + (perlin * 0.4)\n            //     vertex.multiplyScalar( ratio )\n\n            //     mesh.current.geometry.attributes.position.setXYZ(vertIndex, vertex.x, vertex.y, vertex.z)\n            // }\n\n            // position.needsUpdate = true\n            // console.log('UPdated mesh')\n\n        })\n        return (\n          <mesh\n            {...props}\n            ref={mesh}\n            castShadow\n            receiveShadow={false}>\n            <sphereBufferGeometry args={[1,128,128]} /> {/* radius, widthSeg, heightSeg */}\n            <meshStandardMaterial \n                color={0xB5D5FE}\n                roughness={0.6} \n                metalness={0.2} \n                wireframe={false}\n                side={FrontSide} />\n          </mesh>\n        )\n    }\n\n    function Blob(props: JSX.IntrinsicElements['mesh']) {\n        const mesh = useRef<THREE.Mesh>(null!)\n        let ogGeo = useRef<THREE.BufferGeometry>(null!)\n\n        // Saving original position as a reference\n        useEffect(() => {\n            const { geometry } = mesh.current\n            ogGeo.current = geometry  \n        }, [])\n\n\n        // Rotating animation\n        useFrame(() => {\n            mesh.current.rotation.x += 0.005\n            mesh.current.rotation.y -= 0.005\n        })\n\n        // Perlin noise animation\n        useFrame(({ clock }) => {\n            const time = clock.getElapsedTime() // For incrementing perlin noise calc\n            const { geometry } = mesh.current\n            const { position } = geometry.attributes // to access vertices of geometry\n\n            let vertex = new THREE.Vector3() // placeholder for new vertex vals\n            for (let i=0; i < ogGeo.current.attributes.position.count; i++) {\n                vertex.fromBufferAttribute(ogGeo.current.attributes.position, i) // copying original geometry\n                let perlin = noise.simplex3(\n                    (vertex.x * 0.9) + (time * 0.4), // vertex coeffs __\n                    (vertex.y * 0.9)+ (time * 0.4), // time component will affect incrementing steps and spike variance\n                    (vertex.z * 0.9)+ (time * 0.4))\n                let ratio = 1 + (perlin * 0.0005) // perlin ceoff affects range of change from baseline 1\n                vertex.multiplyScalar(ratio)\n                position.setXYZ(i, vertex.x, vertex.y, vertex.z)\n                position.needsUpdate = true\n            }\n            geometry.computeVertexNormals();\n        })\n        return (\n          <mesh\n            {...props}\n            ref={mesh}\n            castShadow\n            receiveShadow={false}>\n            <sphereBufferGeometry args={[ 1.4, 256, 156 ]} /> {/* radius, widthSeg, heightSeg */}\n            <meshStandardMaterial \n                color={0xB5D5FE}\n                roughness={0.6} \n                metalness={0.2} \n                wireframe={false}\n                side={FrontSide} />\n          </mesh>\n        )\n    }\n    \n    return (\n        <div className='bg' id='canvas-container'>\n            {/* default: camera={ fov: 75, near: 0.1, far: 1000, position: [0, 0, 5] } */}\n            <Canvas\n            shadows\n            >\n                {/* <ambientLight intensity={0.1}/> */}\n                <pointLight intensity={0.3} position={[150, 150, 15]}/>\n                <directionalLight color={ 0x0099FA } intensity={ 0.8 } position={[ 0, 350, 350 ]} castShadow={true} />\n                <directionalLight color= { 0x62C7B7 } intensity={ 0.4 } position={[ -300, 400, 350 ]} />\n                <directionalLight color= { 0x62C7B7 } intensity={ 0.2 } position={[ 0, -250, 300 ]} />\n                <hemisphereLight color={ 0xffffff } groundColor={ 0x000000 } intensity={ 0.8 } />\n                {/* <Sphere position={[0,0,0]} /> */}\n                {/* <Skeleton position={[0,0,0]} /> */}\n                <BackgroundPlane position={[ 0, 0, -100 ]} />\n                <BlurPlane position={[ 0, 0, 3 ]}/>\n                <Blob position={[1,0,0]} />\n            </Canvas>\n        </div>\n    )\n}"]},"metadata":{},"sourceType":"module"}